{"version":3,"sources":["utils/generateArrayOfLength.ts","utils/shuffleArray.ts","utils/pointsToColorMap.ts","utils/colorMapToSortingPoints.ts","algoritms/mergeSort.ts","hooks/useInterval.tsx","contexts/SortingContext.tsx","contexts/ArrayContext.tsx","views/Visualizer/Bar.tsx","views/Visualizer/ArrayCanvas.tsx","utils/ValueMapper.ts","views/Visualizer/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["generateArrayOfLength","size","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","shuffleArray","Array","from","x","i","pointsToColorMap","points","isArray","Object","keys","map","key","colorMapToSortingPoints","colorMap","result","entries","forEach","entry","color","point","mergeArray","sort","arr","start","mid","end","start2","value","index","l","r","m","mergeSort","useInterval","callback","delay","savedCallback","useRef","useEffect","current","id","setInterval","clearInterval","SortingStateContext","React","createContext","undefined","SortingProvider","children","useArrayState","useState","sortingAlgorithm","generator","setPoints","frequency","setFrequency","next","done","Provider","ArrayStateContext","ArrayActionsContext","initialArray","ArrayProvider","arrayLength","setArrayLength","setArray","changeArrayLength","n","generateNewArray","replaceArray","context","useContext","Error","Bar","width","height","className","style","backgroundColor","memo","ArrayCanvas","minVal","min","maxVal","max","bars","heightMapper","originalInterval","targetInterval","low1","high1","low2","high2","val","round","ValueMapper","barWidth","display","justifyContent","nr","Visualizer","useSortingState","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f3a843c3.chunk.js","sourcesContent":["import { shuffleArray } from './index';\n\nexport default function generateArrayOfLength(size: number) {\n  const array = Array.from({ length: size }, (x, i) => i);\n\n  return shuffleArray(array);\n}\n","export default function shuffleArray<T>(array: T[]) {\n  let currentIndex = array.length;\n  let temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import { ColorMap } from 'types';\n\ntype Input = number[] | { [key: string]: number | number[] };\nconst defaultColor = 'orange';\n\nconst pointsToColorMap = (points: Input): ColorMap => {\n  if (Array.isArray(points)) {\n    return { [defaultColor]: points };\n  }\n\n  Object.keys(points).map((key) => {\n    if (typeof points[key] === 'number') points[key] = [points[key] as number];\n  });\n\n  return points as ColorMap;\n};\n\nexport default pointsToColorMap;\n","import { ColorMap, SortingPoints } from 'types';\n\nconst colorMapToSortingPoints = (colorMap: ColorMap): SortingPoints => {\n  const result: SortingPoints = {};\n\n  Object.entries(colorMap).forEach((entry) => {\n    const [color, points] = entry;\n\n    points.forEach((point) => (result[point] = color));\n  });\n\n  return result;\n};\n\nexport default colorMapToSortingPoints;\n","import { ColorMapGenerator, SortingFunction } from '../types';\nimport { pointsToColorMap as points } from 'utils';\n\nfunction* mergeArray(\n  arr: number[],\n  start: number,\n  mid: number,\n  end: number\n): ColorMapGenerator {\n  let start2 = mid + 1;\n\n  // If the direct merge is already sorted\n  if (arr[mid] <= arr[start2]) {\n    return;\n  }\n\n  // Two pointers to maintain start\n  // of both arrays to merge\n  while (start <= mid && start2 <= end) {\n    // If element 1 is in right place\n    if (arr[start] <= arr[start2]) {\n      start++;\n    } else {\n      const value = arr[start2];\n      let index = start2;\n\n      // Shift all the elements between element 1\n      // element 2, right by 1.\n      while (index != start) {\n        arr[index] = arr[index - 1];\n        index--;\n      }\n      arr[start] = value;\n\n      // Update all the pointers\n      start++;\n      mid++;\n      start2++;\n      yield points([start, mid]);\n    }\n  }\n}\n\nfunction* sort(arr: number[], l: number, r: number): ColorMapGenerator {\n  if (l < r) {\n    const m = Math.floor(l + (r - l) / 2);\n\n    yield* sort(arr, l, m);\n    yield* sort(arr, m + 1, r);\n\n    yield* mergeArray(arr, l, m, r);\n  }\n}\n\nconst mergeSort: SortingFunction = function* (arr) {\n  yield* sort(arr, 0, arr.length - 1);\n};\n\nexport default mergeSort;\n","import { useRef, useEffect } from 'react';\n\nfunction useInterval(callback: () => void, delay: number | null) {\n  const savedCallback = useRef<() => void | null>();\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      if (typeof savedCallback?.current !== 'undefined') {\n        savedCallback?.current();\n      }\n    }\n    if (delay !== null) {\n      const id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n\nexport default useInterval;\n","import React, { useState } from 'react';\n\nimport { SortingPoints } from 'types';\n\nimport { mergeSort as sortingAlgorithm } from 'algoritms';\nimport { colorMapToSortingPoints } from 'utils';\n\nimport { useInterval } from 'hooks';\nimport { useArrayState } from 'contexts';\n\ntype State = {\n  array: number[];\n  points: SortingPoints;\n};\n\nconst SortingStateContext = React.createContext<State | undefined>(undefined);\n\nconst SortingProvider: React.FC = ({ children }) => {\n  const { array } = useArrayState();\n\n  const [generator] = useState(sortingAlgorithm(array));\n\n  const [points, setPoints] = useState({});\n\n  const [frequency, setFrequency] = useState(30);\n\n  useInterval(() => {\n    const next = generator.next();\n\n    if (next.done) return setFrequency(0);\n\n    const colorMap = next.value;\n    const points = colorMapToSortingPoints(colorMap);\n    setPoints(points);\n  }, 1000 / frequency);\n\n  return (\n    <SortingStateContext.Provider value={{ array, points }}>\n      {children}\n    </SortingStateContext.Provider>\n  );\n};\n\nconst useSortingState = () => {\n  const context = React.useContext(SortingStateContext);\n  if (context === undefined) {\n    throw new Error('useSortingState must be used within a SortingProvider');\n  }\n\n  return context;\n};\n\nexport { useSortingState, SortingProvider };\n","import React, { useState } from 'react';\n\nimport { generateArrayOfLength } from 'utils';\n\ntype State = {\n  array: number[];\n};\n\ntype Actions = {\n  generateNewArray: () => void;\n  changeArrayLength: (arg0: number) => void;\n  replaceArray: (args0: number[]) => void;\n};\n\nconst ArrayStateContext = React.createContext<State | undefined>(undefined);\nconst ArrayActionsContext = React.createContext<Actions | undefined>(undefined);\n\nconst initialLength = 100;\nconst initialArray = generateArrayOfLength(initialLength);\n\nconst ArrayProvider: React.FC = ({ children }) => {\n  // The length is used for generating new arrays\n  const [arrayLength, setArrayLength] = useState(initialLength);\n  const [array, setArray] = useState(initialArray);\n\n  const changeArrayLength = (n: number) => setArrayLength(n);\n\n  const generateNewArray = () => setArray(generateArrayOfLength(arrayLength));\n  const replaceArray = (arr: number[]) => {\n    // Replaces the array with a custom one\n    setArray(arr);\n    setArrayLength(arr.length);\n  };\n\n  return (\n    <ArrayStateContext.Provider value={{ array }}>\n      <ArrayActionsContext.Provider\n        value={{ changeArrayLength, generateNewArray, replaceArray }}\n      >\n        {children}\n      </ArrayActionsContext.Provider>\n    </ArrayStateContext.Provider>\n  );\n};\n\nconst useArrayState = () => {\n  const context = React.useContext(ArrayStateContext);\n  if (context === undefined) {\n    throw new Error('useArrayState must be used within a ArrayProvider');\n  }\n\n  return context;\n};\n\nconst useArrayActions = () => {\n  const context = React.useContext(ArrayActionsContext);\n  if (context === undefined) {\n    throw new Error('useArrayActions must be used within a ArrayProvider');\n  }\n\n  return context;\n};\n\nexport { useArrayState, useArrayActions, ArrayProvider };\n","import React from 'react';\n\ntype Props = {\n  width: number;\n  height: number;\n  color: string;\n};\n\nconst Bar: React.FC<Props> = ({ width, height, color }) => {\n  return (\n    <div className=\"bar\" style={{ width, height, backgroundColor: color }} />\n  );\n};\n\nexport default React.memo(Bar);\n","import React from 'react';\n\nimport { SortingPoints } from 'types';\n\nimport Bar from './Bar';\n\nimport { ValueMapper } from 'utils';\n\ntype Props = {\n  array: number[];\n  points: SortingPoints;\n};\n\nconst ArrayCanvas: React.FC<Props> = ({ array, points }) => {\n  const canvasHeight = 400;\n  const canvasWidth = 600;\n  const gapWidth = 1;\n  const minBarHeight = 10;\n  const barColor = 'blue';\n\n  const minVal = Math.min(...array);\n  const maxVal = Math.max(...array);\n  const bars = array.length;\n\n  const heightMapper = ValueMapper(\n    [minVal, maxVal],\n    [minBarHeight, canvasHeight]\n  );\n  const barWidth = (canvasWidth - bars * gapWidth) / bars;\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        height: canvasHeight,\n        width: canvasWidth,\n      }}\n    >\n      {array.map((nr, index) => (\n        <Bar\n          key={nr}\n          height={heightMapper(nr)}\n          width={barWidth}\n          color={points[index] || barColor}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default ArrayCanvas;\n","type Interval = [number, number];\n\nexport default function ValueMapper(\n  originalInterval: Interval,\n  targetInterval: Interval\n) {\n  const [low1, high1] = originalInterval;\n  const [low2, high2] = targetInterval;\n\n  return (value: number) => {\n    const val = low2 + ((value - low1) * (high2 - low2)) / (high1 - low1);\n\n    return Math.round(val);\n  };\n}\n","import React from 'react';\n\nimport { useSortingState } from 'contexts';\n\nimport ArrayCanvas from './ArrayCanvas';\n\nconst Visualizer: React.FC = () => {\n  const { array, points } = useSortingState();\n\n  return (\n    <div>\n      <ArrayCanvas array={array} points={points} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n","import React from 'react';\n\nimport { Visualizer } from './views';\n\nimport { SortingProvider, ArrayProvider } from './contexts';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ArrayProvider>\n        <SortingProvider>\n          <Visualizer />\n        </SortingProvider>\n      </ArrayProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport './styles/global.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}